package io.opensphere.core.preferences;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;

import org.apache.log4j.Logger;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import io.opensphere.core.util.JAXBContextHelper;
import io.opensphere.core.util.SupplierX;
import io.opensphere.core.util.Utilities;
import io.opensphere.core.util.XMLUtilities;
import io.opensphere.core.util.xml.ByteArrayList;
import io.opensphere.core.util.xml.StringList;
import io.opensphere.core.util.xml.StringMap;
import io.opensphere.core.util.xml.StringSet;

/**
 * A preference key and value pair.
 *
 * @param <T> The type of value held by this object.
 */
@XmlAccessorType(XmlAccessType.NONE)
@SuppressWarnings("PMD.GodClass")
class Preference<T>
{
    /** Logger reference. */
    private static final Logger LOGGER = Logger.getLogger(Preference.class);

    /** The JAXB class for the value. */
    @XmlAttribute(name = "class", required = true)
    private Class<? extends T> myClass;

    /**
     * The data comprising the value of the preference. If this object was
     * generated by JAXB from XML, the data will be a DOM element. If this
     * object was constructed normally, the data will be a reference to the
     * actual value object.
     */
    private Object myData;

    /** The key to the preference. */
    @XmlAttribute(name = "key", required = true)
    private String myKey;

    /** Flag indicating if this preference should be saved. */
    private boolean mySaveable = true;

    /**
     * Create a preference for a DOM element.
     *
     * @param key The preference key.
     * @param value The DOM element.
     * @return The preference.
     * @throws IllegalArgumentException If the key or value is {@code null}.
     */
    public static Preference<Element> createFromDOMElement(String key, Element value) throws IllegalArgumentException
    {
        return new Preference<Element>(key, value);
    }

    /**
     * Constructor for use by other constructors.
     *
     * @param key The preference key.
     * @param value The value object.
     * @throws IllegalArgumentException If the key or value is {@code null}, or
     *             if the value is a {@link JAXBElement}.
     */
    @SuppressWarnings("unchecked")
    public Preference(String key, T value)
    {
        this(key, (Class<? extends T>)Utilities.checkNull(value, "value").getClass(), value);
        if (value instanceof JAXBElement)
        {
            throw new IllegalArgumentException("This constructor cannot be used for JAXBElements.");
        }
    }

    /** Default constructor for JAXB. */
    protected Preference()
    {
    }

    /**
     * Constructor for use by other constructors.
     *
     * @param key The preference key.
     * @param valueType The value type.
     * @param value The value object.
     * @throws IllegalArgumentException If the key or value is {@code null}.
     */
    protected Preference(String key, Class<? extends T> valueType, Object value) throws IllegalArgumentException
    {
        Utilities.checkNull(key, "key");
        Utilities.checkNull(value, "value");

        myKey = key;
        myClass = valueType;
        myData = value;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }
        if (obj == null)
        {
            return false;
        }
        if (!(obj instanceof Preference))
        {
            return false;
        }
        Preference<?> other = (Preference<?>)obj;
        if (!myKey.equals(other.myKey) || !myClass.equals(other.myClass))
        {
            return false;
        }
        // If the value is XML, compare the marshalled versions since DOM
        // elements may not implement equals().
        if (Node.class.isAssignableFrom(myClass))
        {
            synchronized (myData)
            {
                synchronized (other.myData)
                {
                    return XMLUtilities.format((Node)myData).equals(XMLUtilities.format((Node)other.myData));
                }
            }
        }
        else
        {
            try
            {
                return Objects.equals(getValue(), other.getValue());
            }
            catch (JAXBException e)
            {
                LOGGER.warn("JAXBException during equals(): " + e, e);
            }
        }
        return false;
    }

    /**
     * Return the value as a {@code boolean}, or a default if the value cannot
     * be converted to a {@code boolean}.
     *
     * @param def The default value.
     * @return The value.
     */
    public boolean getBooleanValue(boolean def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Boolean)
            {
                return ((Boolean)value).booleanValue();
            }
            else if (value instanceof String)
            {
                return Boolean.parseBoolean((String)value);
            }
            else
            {
                warnWrongValueType(Boolean.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code Boolean}, or a default if the value cannot
     * be converted to a {@code Boolean}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Boolean getBooleanValue(Boolean def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Boolean)
            {
                return (Boolean)value;
            }
            else if (value instanceof String)
            {
                return Boolean.valueOf((String)value);
            }
            else
            {
                warnWrongValueType(Boolean.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a list of byte arrays, or a default if the value is
     * the wrong type.
     *
     * @param def The default value.
     * @return The value.
     */
    public List<byte[]> getByteArrayListValue(List<byte[]> def)
    {
        try
        {
            T value = getValue();
            if (value instanceof ByteArrayList)
            {
                return ((ByteArrayList)value).getArrays();
            }
            else if (value == null)
            {
                return null;
            }
            else
            {
                warnWrongValueType(ByteArrayList.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code byte[]}, or a default if the value is not a
     * {@code byte[]}.
     *
     * @param def The default value.
     * @return The value.
     */
    public byte[] getByteArrayValue(byte[] def)
    {
        try
        {
            T value = getValue();
            if (value instanceof byte[])
            {
                return (byte[])value;
            }
            else
            {
                warnWrongValueType(byte[].class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as an {@code Element}, or a default if the value cannot
     * be converted to an {@code Element}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Element getDOMElementValue(Element def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Element)
            {
                return (Element)value;
            }
            else
            {
                warnWrongValueType(Boolean.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code double}, or a default if the value cannot be
     * converted to a {@code double}.
     *
     * @param def The default value.
     * @return The value.
     */
    public double getDoubleValue(double def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return ((Number)value).doubleValue();
            }
            else if (value instanceof String)
            {
                return Double.parseDouble((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code Double}, or a default if the value cannot be
     * converted to a {@code Double}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Double getDoubleValue(Double def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return Double.valueOf(((Number)value).doubleValue());
            }
            else if (value instanceof String)
            {
                return Double.valueOf((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code float}, or a default if the value cannot be
     * converted to a {@code float}.
     *
     * @param def The default value.
     * @return The value.
     */
    public float getFloatValue(float def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return ((Number)value).floatValue();
            }
            else if (value instanceof String)
            {
                return Float.parseFloat((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code Float}, or a default if the value cannot be
     * converted to a {@code Float}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Float getFloatValue(Float def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return Float.valueOf(((Number)value).floatValue());
            }
            else if (value instanceof String)
            {
                return Float.valueOf((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as an {@code Integer}, or a default if the value cannot
     * be converted to an {@code Integer}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Integer getIntegerValue(Integer def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return Integer.valueOf(((Number)value).intValue());
            }
            else if (value instanceof String)
            {
                return Integer.valueOf((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as an {@code int}, or a default if the value cannot be
     * converted to an {@code int}.
     *
     * @param def The default value.
     * @return The value.
     */
    public int getIntValue(int def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return ((Number)value).intValue();
            }
            else if (value instanceof String)
            {
                return Integer.parseInt((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Accessor for the key.
     *
     * @return The key.
     */
    public String getKey()
    {
        return myKey;
    }

    /**
     * Return the value as a {@code long}, or a default if the value cannot be
     * converted to a {@code long}.
     *
     * @param def The default value.
     * @return The value.
     */
    public long getLongValue(long def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return ((Number)value).longValue();
            }
            else if (value instanceof String)
            {
                return Long.parseLong((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code Long}, or a default if the value cannot be
     * converted to a {@code Long}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Long getLongValue(Long def)
    {
        try
        {
            T value = getValue();
            if (value instanceof Number)
            {
                return Long.valueOf(((Number)value).longValue());
            }
            else if (value instanceof String)
            {
                return Long.valueOf((String)value);
            }
            else
            {
                warnWrongValueType(Number.class, value);
                return def;
            }
        }
        catch (NumberFormatException e)
        {
            warnNumberFormatException(e);
            return def;
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a list of strings, or a default if the value cannot
     * be converted to a {@code List}.
     *
     * @param def The default value.
     * @return The value.
     */
    public List<String> getStringListValue(List<String> def)
    {
        try
        {
            T value = getValue();
            if (value instanceof StringList)
            {
                return ((StringList)value).getStrings();
            }
            else if (value == null)
            {
                return null;
            }
            else
            {
                warnWrongValueType(StringList.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a map of strings to strings, or a default if the
     * value cannot be converted to a {@code Map}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Map<String, String> getStringMapValue(Map<String, String> def)
    {
        try
        {
            T value = getValue();
            if (value instanceof StringMap)
            {
                return ((StringMap)value).getMap();
            }
            else if (value == null)
            {
                return null;
            }
            else
            {
                warnWrongValueType(StringMap.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a set of strings, or a default if the value cannot be
     * converted to a {@code Set}.
     *
     * @param def The default value.
     * @return The value.
     */
    public Set<String> getStringSetValue(Set<String> def)
    {
        try
        {
            T value = getValue();
            if (value instanceof StringSet)
            {
                return ((StringSet)value).getStrings();
            }
            else if (value == null)
            {
                return null;
            }
            else
            {
                warnWrongValueType(StringSet.class, value);
                return def;
            }
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value as a {@code String}, or a default if the value cannot be
     * converted to a {@code String}.
     *
     * @param def The default value.
     * @return The value.
     */
    public String getStringValue(String def)
    {
        try
        {
            return String.valueOf(getValue());
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value, or a default if the value cannot be unmarshalled.
     *
     * @param def The default value.
     * @return The value.
     */
    public T getValue(T def)
    {
        try
        {
            return getValue();
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Return the value, or a default if the value cannot be unmarshalled.
     *
     * @param def The default value.
     * @param contextSupplier Supplier of the JAXB context that will unmarshal
     *            the value.
     * @return The value.
     */
    public T getValue(T def, SupplierX<JAXBContext, JAXBException> contextSupplier)
    {
        try
        {
            return getValue(contextSupplier);
        }
        catch (JAXBException e)
        {
            warnUnmarshalException(e);
            return def;
        }
    }

    /**
     * Accessor for the value type.
     *
     * @return The type.
     */
    public final Class<? extends T> getValueType()
    {
        return myClass;
    }

    @Override
    public int hashCode()
    {
        final int prime = 31;
        int result = 1;
        result = prime * result + myKey.hashCode();
        result = prime * result + myClass.hashCode();
        try
        {
            result = prime * result + getValue().hashCode();
        }
        catch (JAXBException e)
        {
            LOGGER.error("Exception during hashCode(): " + e, e);
        }
        return result;
    }

    /**
     * Get if this preference is a null value.
     *
     * @return {@code true} if the preference is the null value.
     */
    public boolean isNull()
    {
        return getValueType() == Void.class;
    }

    @Override
    public String toString()
    {
        if (myClass == null)
        {
            return getClass().getSimpleName() + " (uninitialized)";
        }
        else
        {
            try
            {
                return getValue().toString();
            }
            catch (JAXBException e)
            {
                return "Could not unmarshal value.";
            }
        }
    }

    /**
     * Validate this preference.
     *
     * @param topic The topic that this preference belongs to, for informational
     *            purposes.
     * @return {@code true} if the preference is valid.
     */
    public boolean validatePreference(String topic)
    {
        boolean valid;
        if (getKey() == null)
        {
            LOGGER.warn("Encountered preference with null key in topic [" + topic + "]");
            valid = false;
        }
        else if (getValueType() == null)
        {
            LOGGER.warn(
                    "Preference in topic [" + topic + "] with key [" + getKey() + "] has an unknown type and is being ignored.");
            valid = false;
        }
        else if (getData() == null)
        {
            LOGGER.warn("Preference in topic [" + topic + "] with key [" + getKey() + "] has no data and is being ignored.");
            valid = false;
        }
        else
        {
            valid = true;
        }
        return valid;
    }

    /**
     * Accessor for the data. If this object was generated by JAXB from XML, the
     * data will be a DOM element. If this object was constructed normally, the
     * data will be a reference to the actual value object
     *
     * @return The data.
     */
    protected final Object getData()
    {
        return myData;
    }

    /**
     * Get the DOM element.
     *
     * @return The element.
     * @throws JAXBException If there is a JAXB error generating the element.
     */
    @XmlAnyElement
    protected Element getElement() throws JAXBException
    {
        return (Element)myData;
    }

    /**
     * Get the value using a JAXB context that only includes my class.
     *
     * @return The value.
     * @throws JAXBException If the value cannot be unmarshalled.
     */
    protected T getValue() throws JAXBException
    {
        return getValue((SupplierX<JAXBContext, JAXBException>)null);
    }

    /**
     * Get the value.
     *
     * @param contextSupplier The supplier of the context to use.
     * @return The value.
     * @throws JAXBException If the value cannot be unmarshalled.
     */
    @SuppressWarnings("unchecked")
    protected T getValue(SupplierX<JAXBContext, JAXBException> contextSupplier) throws JAXBException
    {
        if (myClass.isInstance(myData))
        {
            return (T)myData;
        }
        else
        {
            JAXBContext context2 = contextSupplier == null ? JAXBContextHelper.getCachedContext(myClass) : contextSupplier.get();
            synchronized (myData)
            {
                return XMLUtilities.readXMLObject((Element)myData, context2, myClass);
            }
        }
    }

    /**
     * Set the DOM element.
     *
     * @param e The element.
     */
    protected void setElement(Element e)
    {
        myData = e;
    }

    /**
     * Log a warning for a number format exception.
     *
     * @param e The exception.
     */
    protected void warnNumberFormatException(NumberFormatException e)
    {
        LOGGER.warn("Failed to parse number for key [" + getKey() + "]: " + e, e);
    }

    /**
     * Log a warning for an unmarshal exception.
     *
     * @param e The exception.
     */
    protected void warnUnmarshalException(JAXBException e)
    {
        LOGGER.warn("Failed to unmarshal preference value for key [" + getKey() + "]: " + e, e);
    }

    /**
     * Log a warning for a property value that is not convertible to the
     * requested type.
     *
     * @param requested The requested type.
     * @param value The property value.
     */
    protected void warnWrongValueType(Class<?> requested, Object value)
    {
        if (value == null)
        {
            LOGGER.warn(requested.getName() + " requested for preference key [" + getKey() + "], but value is null.");
        }
        else
        {
            LOGGER.warn(requested.getName() + " requested for preference key [" + getKey() + "], but value is actually a "
                    + value.getClass().getName());
        }
    }

    /**
     * Get if this preference should be saved.
     *
     * @return {@code true} if this preference is saveable.
     */
    boolean isSaveable()
    {
        return mySaveable;
    }

    /**
     * Set if this preference should be saved.
     *
     * @param saveable {@code true} if this preference is saveable.
     */
    void setSaveable(boolean saveable)
    {
        mySaveable = saveable;
    }
}
