package io.opensphere.core.data;

import java.util.Collection;
import java.util.Date;
import java.util.Set;
import java.util.concurrent.ThreadPoolExecutor;

import com.vividsolutions.jts.geom.Geometry;

import io.opensphere.core.api.Envoy;
import io.opensphere.core.api.Transformer;
import io.opensphere.core.cache.CacheDeposit;
import io.opensphere.core.cache.CacheModificationListener;
import io.opensphere.core.cache.ClassProvider;
import io.opensphere.core.cache.DefaultCacheDeposit;
import io.opensphere.core.cache.SimplePersistentCacheDeposit;
import io.opensphere.core.cache.SimpleSessionOnlyCacheDeposit;
import io.opensphere.core.cache.accessor.GeometryAccessor;
import io.opensphere.core.cache.accessor.PropertyAccessor;
import io.opensphere.core.cache.accessor.PropertyArrayAccessor;
import io.opensphere.core.cache.accessor.SerializableAccessor;
import io.opensphere.core.cache.accessor.TimeSpanAccessor;
import io.opensphere.core.cache.matcher.PropertyMatcher;
import io.opensphere.core.cache.util.PropertyDescriptor;
import io.opensphere.core.data.util.DataModelCategory;
import io.opensphere.core.data.util.DefaultQuery;
import io.opensphere.core.data.util.KeyValueQuery;
import io.opensphere.core.data.util.Query;
import io.opensphere.core.data.util.QueryTracker;
import io.opensphere.core.data.util.SimpleQuery;
import io.opensphere.core.util.Service;

/**
 * Registry for data models. Data models are produced by {@link Envoy}s and used
 * by {@link Transformer}s, as well as other plug-in components.
 * <p>
 * To add models to the registry, call {@link #addModels(CacheDeposit)}. Each
 * deposit has an expiration date. After the expiration, the models will no
 * longer appear in query results, and the registry is free to delete the data.
 * To make models only last for the current session, specify an expiration date
 * of {@link CacheDeposit#SESSION_END}. If the models should never expire,
 * simply construct a {@link Date} with a large number, like
 * {@link Long#MAX_VALUE}. Each deposit also has a <i>critical</i> flag. If a
 * deposit is critical, it will not be eligible for deletion when the database
 * is cleaned.
 * <p>
 * The data registry can store objects either in-memory only, or persistently to
 * disk. Objects that are in-memory only will obviously not appear in the
 * registry when the application is restarted, regardless of expiration date.
 * Objects stored persistently may also be cached in-memory for quick retrieval.
 * <p>
 * Clients of the data registry decide how their data should be represented in
 * the registry. For low-volume simple data, it may be easiest to simply store
 * the data models wholesale. If all the models within a category will always be
 * retrieved, no additional properties are needed.
 * <p>
 * To do this simplest case, follow these steps:
 * <ol>
 * <li>Construct a {@link DataModelCategory} for the models.</li>
 * <li>Build a {@link PropertyDescriptor}. The property name in the property
 * descriptor can be any string. The property type should be the class of the
 * data models.</li>
 * <li>Create one of the following:
 * <ul>
 * <li>
 * {@link SimplePersistentCacheDeposit#SimplePersistentCacheDeposit(DataModelCategory, PropertyDescriptor, Collection, Date)}
 * if your models are serializable and you want them to be stored persistently.
 * .</li>
 * <li>
 * {@link SimpleSessionOnlyCacheDeposit#SimpleSessionOnlyCacheDeposit(DataModelCategory, PropertyDescriptor, Collection)}
 * if your models are not serializable or you do not want them to be stored
 * persistently. .</li>
 * </ul>
 * </li>
 * <li>Call {@link #addModels(CacheDeposit)} with your {@link CacheDeposit}.
 * </ol>
 * <p>
 * The call to {@link #addModels(CacheDeposit)} will return an array of unique
 * numeric ids generated by the registry, one for each input object. These ids
 * may be used later to update or retrieve the objects.
 * <p>
 * Models added in this manner will only be query-able by their id or
 * {@link DataModelCategory} and serialized representation. It may be necessary
 * for data models to be query-able by some other property, such as a string
 * key. To associate additional properties with the models, follow these steps:
 * <ol>
 * <li>Build a {@link PropertyDescriptor} for each property. Each property
 * should have a different property name. Property types may be duplicated,
 * except in the case of {@link Geometry}s.</li>
 * <li>Create a {@link PropertyAccessor} for each property that will extract the
 * property values from the model objects. In most cases,
 * {@link SerializableAccessor} can be used. For more complicated cases, see
 * also {@link TimeSpanAccessor}, {@link GeometryAccessor}, and
 * {@link PropertyArrayAccessor}</li>
 * <li>If you still want to store your data model serialized, you'll also need
 * to create an accessor for the data model itself. See
 * {@link SerializableAccessor#getHomogeneousAccessor} for a way to easily
 * create it.</li>
 * <li>Since more than one accessor will be needed, use a
 * {@link DefaultCacheDeposit} rather than the simpler versions suggested above.
 * </li>
 * </ol>
 * <p>
 * To retrieve values from the registry, the simplest case is to get all values
 * that match a {@link DataModelCategory} and a {@link PropertyDescriptor}.
 * These objects can be the same as what was provided in the
 * {@link #addModels(CacheDeposit)} call. Components of the
 * {@link DataModelCategory} may also be {@code null} to indicate a wild-card.
 * For example, it may not matter what the source of the objects is, so the
 * <i>source</i> in the {@link DataModelCategory} could be {@code null}. To do a
 * query like this, do the following:
 * <ol>
 * <li>Use the constructor
 * {@link SimpleQuery#SimpleQuery(DataModelCategory, PropertyDescriptor)} with
 * your property descriptor to create a {@link Query} object.</li>
 * <li>Call {@link #submitQuery(Query)} with the {@link DataModelCategory} and
 * the {@link Query} object.</li>
 * <li>Call {@link SimpleQuery#getResults()} to get the query results.</li>
 * </ol>
 * <p>
 * To get a value of one property that goes with a specified value of another
 * property, use {@link KeyValueQuery}.
 * <p>
 * To do more complex queries, see the subclasses of {@link PropertyMatcher}.
 * One or more matchers may be passed to
 * {@link SimpleQuery#SimpleQuery(DataModelCategory, PropertyDescriptor, java.util.List)}
 * .
 * <p>
 * Also see {@link DefaultQuery} to do ordered or row-limited queries.
 */
public interface DataRegistry
{
    /**
     * Add a listener to be notified of data registry modifications.
     *
     * @param <T> The type of the property values of interest to the listener.
     * @param listener The listener.
     * @param dataModelCategory The data model category of interest. The data
     *            model category may contain {@code null}s to indicate
     *            wildcards.
     * @param propertyDescriptor Descriptor for the property the listener is
     *            interested in.
     */
    <T> void addChangeListener(DataRegistryListener<T> listener, DataModelCategory dataModelCategory,
            PropertyDescriptor<T> propertyDescriptor);

    /**
     * Adds a class provider to the registry.
     *
     * @param provider A class provider to use when the system class loader
     *            fails.
     */
    void addClassProvider(ClassProvider provider);

    /**
     * Add a data provider to the registry. If a query is submitted to the
     * registry that cannot be satisfied by the caches, the data providers will
     * be queried.
     *
     * @param dataProvider The data provider.
     * @param executor An executor to use for queries against this data
     *            provider.
     */
    void addDataProvider(DataRegistryDataProvider dataProvider, ThreadPoolExecutor executor);

    /**
     * Add models to the registry.
     *
     * @param <T> The type of models being added.
     * @param deposit The collection of models.
     * @return The id numbers for the added models, or {@code null} if there's a
     *         failure.
     */
    <T> long[] addModels(CacheDeposit<T> deposit);

    /**
     * Add models to the registry.
     *
     * @param <T> The type of models being added.
     * @param deposit The collection of models.
     * @param source The originator of the change.
     * @return The id numbers for the added models, or {@code null} if there's a
     *         failure.
     */
    <T> long[] addModels(CacheDeposit<T> deposit, Object source);

    /**
     * Free any resources used by this data registry.
     */
    void close();

    /**
     * Get the data model categories for some models. This method returns one
     * data model category for each id provided.
     *
     * @param ids The id numbers of the models.
     * @return The data model categories, or {@code null} if there's a failure.
     */
    DataModelCategory[] getDataModelCategories(long[] ids);

    /**
     * Get the data model categories for some models. This method does not
     * return duplicates, so if all the models belong to the same category, only
     * one category will be returned.
     *
     * @param ids The id numbers of the models.
     * @param source Flag indicating that the source of the data model
     *            categories needs to be populated.
     * @param family Flag indicating that the family of the data model
     *            categories needs to be populated.
     * @param category Flag indicating that the category of the data model
     *            categories needs to be populated.
     * @return The data model categories, or {@code null} if there's a failure.
     */
    Set<DataModelCategory> getDataModelCategories(long[] ids, boolean source, boolean family, boolean category);

    /**
     * Get the sizes of models persisted in the registry.
     *
     * @param ids The id numbers of the models.
     * @param propertyDescriptor The descriptor for the property whose value
     *            sizes are to be returned.
     * @return The sizes in bytes of the models, in the same order as the ids,
     *         or {@code null} if there's a failure.
     */
    long[] getPersistedSizes(long[] ids, PropertyDescriptor<?> propertyDescriptor);

    /**
     * Get if there is a data provider that can immediately provide data for the
     * given data model category.
     *
     * @param dmc The data model category.
     * @return {@code true} if there is an available data provider.
     */
    boolean hasThreadCapacity(DataModelCategory dmc);

    /**
     * Retrieve model properties from the registry by id. This method will only
     * return models that are cached locally.
     *
     * @param ids The id numbers of the models.
     * @param query The query object that specifies what properties should be
     *            retrieved and what should be done with them. The category of
     *            the query as well as any parameters or order specifiers in the
     *            query will be ignored.
     * @return The number of ids that were matched.
     */
    int performLocalQuery(long[] ids, Query query);

    /**
     * Retrieve model properties from the registry. This call is similar to
     * {@link #performQuery(Query)}, but it will only query data cached locally.
     *
     * @param query The query object that specifies what properties should be
     *            retrieved and how.
     * @return The id numbers for the models that match the query.
     */
    long[] performLocalQuery(Query query);

    /**
     * Retrieve model properties from the registry. This will query the local
     * cache as well as any data providers that the registry knows about.
     * <p>
     * If the request is an interval query, results will be returned once all
     * intervals are satisfied or the data providers are exhausted. If the
     * request is not an interval query, results will be returned as soon as any
     * are found, either from the cache or one of the data providers.
     *
     * @param query The query object that specifies what properties should be
     *            retrieved and how.
     * @return The tracker for the query.
     */
    QueryTracker performQuery(Query query);

    /**
     * Remove a listener.
     *
     * @param listener The listener.
     */
    void removeChangeListener(DataRegistryListener<?> listener);

    /**
     * Removes an already added class provider.
     *
     * @param provider The class provider to remove.
     */
    void removeClassProvider(ClassProvider provider);

    /**
     * Remove a data provider from the registry.
     *
     * @param dataProvider The data provider.
     */
    void removeDataProvider(DataRegistryDataProvider dataProvider);

    /**
     * Remove models that match the given category and keys.
     *
     * @param category The category to remove. If any of the values are
     *            {@code null} in the category, they match anything.
     * @param returnIds Indicates if the caller needs to affected model ids to
     *            be returned. Setting this to {@code false} may speed up the
     *            return.
     * @return The id numbers that were removed, if {@code returnIds} is
     *         {@code true}, otherwise {@code null}.
     */
    long[] removeModels(DataModelCategory category, boolean returnIds);

    /**
     * Remove models that match the given category and keys.
     *
     * @param category The category to remove. If any of the values are
     *            {@code null} in the category, they match anything.
     * @param returnIds Indicates if the caller needs the affected model ids to
     *            be returned. Setting this to {@code false} may speed up the
     *            return.
     * @param source The originator of the change.
     * @return The id numbers that were removed, if {@code returnIds} is
     *         {@code true}, otherwise {@code null}.
     */
    long[] removeModels(DataModelCategory category, boolean returnIds, Object source);

    /**
     * Remove models that match the given id numbers.
     *
     * @param ids An array of id numbers.
     */
    void removeModels(long[] ids);

    /**
     * Remove models that match the given id numbers.
     *
     * @param ids An array of id numbers.
     * @param waitForListeners Indicates if this method call should wait for
     *            listeners to be notified before returning.
     * @param source The originator of the change.
     */
    void removeModels(long[] ids, boolean waitForListeners, Object source);

    /**
     * Remove models that match the given id numbers.
     *
     * @param ids An array of id numbers.
     * @param source The originator of the change.
     */
    void removeModels(long[] ids, Object source);

    /**
     * Submit a query to be processed by the registry asynchronously. This will
     * query the local cache only.
     *
     * @param query The query object that specifies what properties should be
     *            retrieved and how.
     * @return A tracker for the query.
     */
    QueryTracker submitLocalQuery(Query query);

    /**
     * Submit a query to be processed by the registry asynchronously. This will
     * query the local cache as well as any data providers that the registry
     * knows about.
     *
     * @param query The query object that specifies what properties should be
     *            retrieved and how.
     * @return A tracker for the query.
     */
    QueryTracker submitQuery(Query query);

    /**
     * Update models in the registry. This version is for updating all models
     * that match the data model category specified in the deposit.
     * <p>
     * The number of objects in the deposit must match the number of models in
     * the registry, unless all the models are being updated from a single
     * object.
     * <p>
     * Interval properties such as time spans or geometries can be added to
     * existing records, but cannot be changed once they are added.
     * <p>
     * To update models using their id numbers, see
     * {@link #updateModels(long[], Collection, Collection, CacheModificationListener)}
     * .
     *
     * @param <T> The type of models being updated.
     * @param deposit The collection of models.
     * @param listener An optional listener for cache modification reports that
     *            contain the affected data model categories, id numbers, and
     *            property descriptors.
     * @see #updateModels(long[], Collection, Collection,
     *      CacheModificationListener)
     */
    <T> void updateModels(CacheDeposit<T> deposit, CacheModificationListener listener);

    /**
     * Update models in the registry. Interval properties such as time spans or
     * geometries can be added to existing records, but cannot be changed once
     * they are added. To update models using their id numbers, see
     * {@link #updateModels(long[], Collection, Collection, CacheModificationListener)}
     * .
     *
     * @param <T> The type of models being updated.
     * @param deposit The collection of models.
     * @param source The originator of the change.
     * @param listener An optional listener for cache modification reports that
     *            contain the affected data model categories, id numbers, and
     *            property descriptors.
     * @see #updateModels(long[], Collection, Collection,
     *      CacheModificationListener)
     */
    <T> void updateModels(CacheDeposit<T> deposit, Object source, CacheModificationListener listener);

    /**
     * Update some property values in the registry. If the ids are not known,
     * {@link #updateModels(CacheDeposit, CacheModificationListener)} may also
     * be used to perform an update.
     *
     * @param <T> The type of the input objects.
     * @param ids The id numbers for the models to be updated.
     * @param input The input objects that provide the new property values. This
     *            may either be a singleton, in which case the same value is
     *            used for all the records, or it may be a collection with the
     *            same size as the id array, in which case the elements will be
     *            matched one-to-one with the ids in the iteration order of the
     *            collection.
     * @param accessors The accessor that provides access to the new property
     *            values from the input object.
     * @param listener An optional listener for cache modification reports that
     *            contain the affected data model categories, id numbers, and
     *            property descriptors.
     * @see #updateModels(CacheDeposit, CacheModificationListener)
     */
    <T> void updateModels(long[] ids, Collection<? extends T> input,
            Collection<? extends PropertyAccessor<? super T, ?>> accessors, CacheModificationListener listener);

    /**
     * Update some property values in the registry. If the ids are not known,
     * {@link #updateModels(CacheDeposit, CacheModificationListener)} may also
     * be used to perform an update.
     * <p>
     * This call has the option of returning as soon as the nearest-line cache
     * is updated. Change listeners will not be notified until after the
     * persistent cache update is complete.
     *
     * @param <T> The type of the input objects.
     * @param ids The id numbers for the models to be updated.
     * @param input The input objects that provide the new property values. This
     *            may either be a singleton, in which case the same value is
     *            used for all the records, or it may be a collection with the
     *            same size as the id array, in which case the elements will be
     *            matched one-to-one with the ids in the iteration order of the
     *            collection.
     * @param accessors The accessor that provides access to the new property
     *            values from the input object.
     * @param source The originator of the change.
     * @param returnEarly If {@code true}, this call will return after the
     *            in-memory registry is updated, and will perform the update of
     *            the persistent registry on another thread.
     * @param listener An optional listener for cache modification reports that
     *            contain the affected data model categories, id numbers, and
     *            property descriptors.
     *
     * @see #updateModels(CacheDeposit, CacheModificationListener)
     */
    <T> void updateModels(long[] ids, Collection<? extends T> input,
            Collection<? extends PropertyAccessor<? super T, ?>> accessors, Object source, boolean returnEarly,
            CacheModificationListener listener);

    /**
     * Creates a service that can be used to add/remove the given listener.
     *
     * @param <T> The type of the property values of interest to the listener.
     * @param listener The listener.
     * @param dataModelCategory The data model category of interest. The data
     *            model category may contain {@code null}s to indicate
     *            wildcards.
     * @param propertyDescriptor Descriptor for the property the listener is
     *            interested in.
     * @return the service
     */
    default <T> Service getChangeListenerService(final DataRegistryListener<T> listener,
            final DataModelCategory dataModelCategory, final PropertyDescriptor<T> propertyDescriptor)
    {
        return new Service()
        {
            @Override
            public void open()
            {
                addChangeListener(listener, dataModelCategory, propertyDescriptor);
            }

            @Override
            public void close()
            {
                removeChangeListener(listener);
            }
        };
    }
}
